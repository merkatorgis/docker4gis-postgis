#!/bin/bash
# set -x

EXCLUDE_SCHEMA=$EXCLUDE_SCHEMA
cores=$(nproc --all)
jobs=$cores

schema=
database=$POSTGRES_DB

for _ in '-n' '-d'; do
    case "$1" in
    -n)
        schema=$2 && shift 2
        ;;
    -d)
        database=$2 && shift 2
        ;;
    esac
done

dir=/fileport/$DOCKER_USER/dump/$database
[ "$schema" ] && dir=$dir/$schema
mkdir -p "$dir"

roles=$dir/roles
backup=$dir/backup
lst=$backup.lst
err=$dir/err

tag() {
    tag=$(date -I'seconds')
    for f in "$roles" "$backup" "$lst" "$err"; do
        [ -e "$f" ] &&
            mv "$f" "$f.$tag"
    done
    return 0
}

sql() {
    local dbname=$database
    [ "$1" = "-d" ] && dbname=$2 && shift 2
    run() {
        # use --no-align and --tuples-only to return a proper, unformatted
        # value that can be used in conditional statements
        psql -U "$POSTGRES_USER" -d "$dbname" --no-align --tuples-only "$@"
    }
    local input=$1 && shift 1
    if [ "$input" ]; then
        if [ -f "$input" ]; then
            # read from given file
            run -f "$input" "$@"
        else
            # execute given sql command
            run -c "$input" "$@"
        fi
    else
        # read from stdin
        run
    fi
}

# create a new dump, while online
dump() {
    # save app.jwt_secret and any other settings passed as an argument, to get
    # set again as part of the restore
    local settings="
        -- if we're upgrading, we're in default read-only mode
        start transaction read write;

        drop function if exists __restore_settings;
        create function __restore_settings()
        returns void language plpgsql as \$body\$ begin
    "
    local value
    for setting in app.jwt_secret "$@"; do
        value=$(sql "select current_setting('$setting', true)")
        settings+="alter database $database set $setting to '$value';"
    done
    settings+="
        -- clean up after ourselves
        drop function __restore_settings;
        end \$body\$;
        commit;
    "
    time {
        sql "$settings" &&
            # tag any existing dump files, so that we won't overwrite them
            tag &&
            # save roles (they're not included in pg_dump's backup file)
            pg_dumpall -U "$POSTGRES_USER" --roles-only >"$roles" &&
            # backup database
            # https://postgis.net/docs/manual-dev/postgis_administration.html#hard_upgrade
            pg_dump \
                --username="$POSTGRES_USER" \
                --dbname="$database" \
                --exclude-schema="$EXCLUDE_SCHEMA" \
                --format=custom \
                --blobs \
                --verbose \
                --file="$backup" &&
            # we don't need this in the database anymore; it just needed to be
            # included in the dump
            sql "
                start transaction read write;
                drop function if exists __restore_settings;
                commit;
            " &&
            echo "Dump created: '$backup'"
    }
}

analyze() {
    # "it is wise to run ANALYZE after restoring from a dump file"
    # https://www.postgresql.org/docs/13/app-pgdump.html
    time {
        echo "Waiting for ANALYZE to complete..."
        sql "analyze"
    }
}

restore() {

    do_restore() {
        # first restore the roles (which are not included in the backup file)
        sql "$roles" || return

        # prevent "schema already exists" errors
        sql "drop schema if exists tiger_data cascade"
        sql "drop schema if exists tiger cascade"

        # restore from the backup file
        # https://postgis.net/docs/manual-dev/postgis_administration.html#hard_upgrade
        local postgis_restore_pl
        postgis_restore_pl=$(find / -name postgis_restore.pl 2>/dev/null)
        echo "Restoring using '$postgis_restore_pl'..."
        local success=false &&
            perl "$postgis_restore_pl" "$backup" | sql 2>"$err" &&
            sql "select __restore_settings()" &&
            # tag the current dump files as done
            tag &&
            echo "Restored: '$backup.$tag'" &&
            success=true

        echo "> Listing '$err.$tag':"
        cat "$err.$tag"
        echo "< Listing '$err.$tag' completed"

        # return true (0) or false (1)
        $success
    }

    # if the database was not yet provisioned, try to restore a dump, if present
    sql "select current_setting('app.provisioned')" ||
        if [ -f "$roles" ] && [ -f "$backup" ]; then
            time do_restore && analyze
        fi

    # mark the database as provisioned in all cases, since if we weren't
    # restoring a dump, we're expected to be provisioning the database from DDL
    # instead
    sql "alter database $database set app.provisioned to true"
}

schema() {
    # ensure a schema name is specified
    [ "$schema" ] && return
    echo "Must specify schema, e.g. dump_schema -n <schema-name>" &&
        exit 22
}

dump_schema() {
    time {
        schema &&
            # tag any existing dump files, so that we won't overwrite them
            tag &&
            # only the directory format supports dumping with parallel jobs
            pg_dump \
                --username="$POSTGRES_USER" \
                --dbname="$database" \
                --schema="$schema" \
                --format=directory \
                --blobs \
                --verbose \
                --jobs="$jobs" \
                --file="$backup" &&
            echo "Dump created: '$backup'" &&
            chmod +rx "$backup" &&
            version=$(sql "select $schema.__version()" -At 2>/dev/null) &&
            echo "$version" >"$backup/__version"
    }
}

restore_schema() {
    time {
        schema &&
            sql "create schema $schema" &&
            pg_restore \
                --username="$POSTGRES_USER" \
                --dbname="$database" \
                --create \
                --schema="$schema" \
                --verbose \
                --jobs="$jobs" \
                "$backup" &&
            sql "
                grant usage on schema $schema to public;
                grant select on all tables in schema $schema to public;
            " &&
            # tag the current dump files as done
            tag &&
            echo "Restored: '$backup.$tag'"
    } && analyze
}

# render the database read-only, before creating a new dump - restore the dump
# in a new, empty database to get it writable again
upgrade() {

    # connect to NOT the database at hand
    sql -d postgres "
        -- temporarily disallow new connections
        -- https://www.postgresql.org/docs/13/sql-alterdatabase.html
        alter database $database allow_connections false;

        -- make future connections read-only
        -- https://www.postgresql.org/docs/13/runtime-config-client.html
        alter database $database set default_transaction_read_only to on;

        -- terminate any (presumably writable) connections
        -- https://www.postgresql.org/docs/13/functions-admin.html
        -- https://www.postgresql.org/docs/13/monitoring-stats.html#MONITORING-PG-STAT-ACTIVITY-VIEW
        select pg_terminate_backend(pid) from pg_stat_activity where datname = '$database';

        -- reallow new (read-only) connections
        alter database $database allow_connections true;
    " &&
        dump "$@" &&
        (
            echo >&2
            echo "NOTICE: since an 'upgrade' dump was created, database $database is now read-only..." >&2
            echo "  See https://github.com/merkatorgis/docker4gis/blob/master/docs/postgis.md#upgrade..." >&2
        )
}

# dump or restore or upgrade or dump_schema or restore_schema (see Dockerfile)
action=$(basename "$0")
$action "$@"
